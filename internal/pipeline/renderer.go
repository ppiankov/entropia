package pipeline

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/ppiankov/entropia/internal/model"
)

// Renderer renders reports in various formats
type Renderer struct {
	IncludeFooter bool // Whether to include "Generated by Entropia" footer
}

// NewRenderer creates a new renderer
func NewRenderer(includeFooter bool) *Renderer {
	return &Renderer{
		IncludeFooter: includeFooter,
	}
}

// RenderJSON writes the report as JSON to the specified path
func (r *Renderer) RenderJSON(report *model.Report, path string) (err error) {
	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("create file: %w", err)
	}
	defer func() {
		if closeErr := f.Close(); closeErr != nil && err == nil {
			err = fmt.Errorf("close file: %w", closeErr)
		}
	}()

	encoder := json.NewEncoder(f)
	encoder.SetIndent("", "  ")
	if err := encoder.Encode(report); err != nil {
		return fmt.Errorf("encode JSON: %w", err)
	}

	return nil
}

// RenderMarkdown writes the report as Markdown to the specified path
func (r *Renderer) RenderMarkdown(report *model.Report, path string) (err error) {
	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("create file: %w", err)
	}
	defer func() {
		if closeErr := f.Close(); closeErr != nil && err == nil {
			err = fmt.Errorf("close file: %w", closeErr)
		}
	}()

	// Helpers for writing with error checking
	printf := func(format string, a ...interface{}) {
		if err != nil {
			return
		}
		_, err = fmt.Fprintf(f, format, a...)
	}
	println := func(a ...interface{}) {
		if err != nil {
			return
		}
		_, err = fmt.Fprintln(f, a...)
	}

	// Header
	printf("# Entropia Report: %s\n\n", report.Subject)
	printf("**Source:** %s\n\n", report.SourceURL)
	printf("**Fetched:** %s\n\n", report.FetchedAt.Format("2006-01-02 15:04:05 UTC"))

	// Support Index
	printf("## Support Index: %d / 100\n\n", report.Score.Index)
	printf("**Confidence:** %s\n\n", report.Score.Confidence)
	if report.Score.Conflict {
		printf("**âš ï¸ Conflict Detected:** Mutually exclusive claims present\n\n")
	}

	// Detected Claims
	printf("## Detected Claims (%d)\n\n", len(report.Claims))
	if len(report.Claims) > 0 {
		for i, claim := range report.Claims {
			if i >= 10 {
				printf("\n*... and %d more claims*\n", len(report.Claims)-10)
				break
			}
			printf("%d. %s\n", i+1, claim.Text)
		}
	} else {
		printf("*No claims detected*\n")
	}
	println()

	// Evidence
	printf("## Evidence Links (%d)\n\n", len(report.Evidence))
	if len(report.Evidence) > 0 {
		// Group by authority tier
		primaryEvidence := []model.Evidence{}
		secondaryEvidence := []model.Evidence{}
		tertiaryEvidence := []model.Evidence{}

		for _, ev := range report.Evidence {
			switch ev.Authority {
			case model.TierPrimary:
				primaryEvidence = append(primaryEvidence, ev)
			case model.TierSecondary:
				secondaryEvidence = append(secondaryEvidence, ev)
			default:
				tertiaryEvidence = append(tertiaryEvidence, ev)
			}
		}

		if len(primaryEvidence) > 0 {
			printf("### Primary Sources (%d)\n\n", len(primaryEvidence))
			for i, ev := range primaryEvidence {
				if i >= 5 {
					break
				}
				printf("- [%s](%s)\n", ev.Host, ev.URL)
			}
			println()
		}

		if len(secondaryEvidence) > 0 {
			printf("### Secondary Sources (%d)\n\n", len(secondaryEvidence))
			for i, ev := range secondaryEvidence {
				if i >= 5 {
					break
				}
				printf("- [%s](%s)\n", ev.Host, ev.URL)
			}
			println()
		}

		if len(tertiaryEvidence) > 0 {
			printf("### Tertiary Sources (%d)\n\n", len(tertiaryEvidence))
			for i, ev := range tertiaryEvidence {
				if i >= 5 {
					break
				}
				printf("- [%s](%s)\n", ev.Host, ev.URL)
			}
			println()
		}
	} else {
		printf("*No evidence links found*\n\n")
	}

	// Diagnostic Signals
	printf("## Diagnostic Signals\n\n")
	for _, signal := range report.Score.Signals {
		icon := "â„¹ï¸"
		switch signal.Severity {
		case model.SeverityWarning:
			icon = "âš ï¸"
		case model.SeverityCritical:
			icon = "ğŸ”´"
		}

		printf("%s **%s**: %s\n", icon, signal.Type, signal.Description)

		// Show key data points
		if signal.Data != nil {
			if score, ok := signal.Data["score"]; ok {
				printf("   - Score: %v\n", score)
			}
			if formula, ok := signal.Data["formula"]; ok {
				printf("   - Formula: `%v`\n", formula)
			}
		}
		println()
	}

	// Validation Summary
	if len(report.Validation) > 0 {
		printf("## Validation Summary\n\n")

		accessibleCount := 0
		deadCount := 0
		staleCount := 0

		for _, v := range report.Validation {
			if v.IsAccessible {
				accessibleCount++
			}
			if v.IsDead {
				deadCount++
			}
			if v.IsStale {
				staleCount++
			}
		}

		printf("- Total evidence validated: %d\n", len(report.Validation))
		printf("- Accessible: %d (%.0f%%)\n", accessibleCount, float64(accessibleCount)/float64(len(report.Validation))*100)
		printf("- Dead links: %d\n", deadCount)
		printf("- Stale sources (>1 year): %d\n", staleCount)
		println()
	}

	// Principles
	printf("## Principles Applied\n\n")
	printf("- **Non-Normative**: Evaluates support, not truth\n")
	printf("- **Transparent**: All scoring explainable\n")
	printf("- **Symmetric**: Same rules for all sources\n\n")

	// Footer (optional, configurable)
	if r.IncludeFooter {
		printf("---\n\n")
		printf("*Generated by Entropia â€” a mirror, not an oracle*\n")
	}

	return err
}

// RenderLLMMarkdown writes the LLM summary markdown to a separate file
func (r *Renderer) RenderLLMMarkdown(content string, path string) (err error) {
	if content == "" {
		return nil
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("create file: %w", err)
	}
	defer func() {
		if closeErr := f.Close(); closeErr != nil && err == nil {
			err = fmt.Errorf("close file: %w", closeErr)
		}
	}()

	_, err = f.WriteString(content)
	if err != nil {
		return fmt.Errorf("write content: %w", err)
	}

	return nil
}

// RenderSummary renders a brief text summary to stdout
func (r *Renderer) RenderSummary(report *model.Report) {
	fmt.Printf("\n")
	fmt.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
	fmt.Printf("  Entropia Report: %s\n", report.Subject)
	fmt.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
	fmt.Printf("\n")
	fmt.Printf("  Support Index:  %d / 100  (%s confidence)\n", report.Score.Index, report.Score.Confidence)
	fmt.Printf("  Claims:         %d\n", len(report.Claims))
	fmt.Printf("  Evidence:       %d\n", len(report.Evidence))

	if report.Score.Conflict {
		fmt.Printf("  âš ï¸  Conflict:    Detected\n")
	}

	fmt.Printf("\n")
	fmt.Printf("  Signals:\n")
	for _, signal := range report.Score.Signals {
		icon := "  â„¹ï¸"
		switch signal.Severity {
		case model.SeverityWarning:
			icon = "  âš ï¸"
		case model.SeverityCritical:
			icon = "  ğŸ”´"
		}
		fmt.Printf("%s  %s\n", icon, strings.Split(signal.Description, "\n")[0])
	}

	fmt.Printf("\n")
	fmt.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
	fmt.Printf("\n")
}