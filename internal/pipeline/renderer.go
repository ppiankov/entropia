package pipeline

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/ppiankov/entropia/internal/model"
)

// Renderer renders reports in various formats
type Renderer struct {
	IncludeFooter bool // Whether to include "Generated by Entropia" footer
}

// NewRenderer creates a new renderer
func NewRenderer(includeFooter bool) *Renderer {
	return &Renderer{
		IncludeFooter: includeFooter,
	}
}

// RenderJSON writes the report as JSON to the specified path
func (r *Renderer) RenderJSON(report *model.Report, path string) error {
	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("create file: %w", err)
	}
	defer f.Close()

	encoder := json.NewEncoder(f)
	encoder.SetIndent("", "  ")
	if err := encoder.Encode(report); err != nil {
		return fmt.Errorf("encode JSON: %w", err)
	}

	return nil
}

// RenderMarkdown writes the report as Markdown to the specified path
func (r *Renderer) RenderMarkdown(report *model.Report, path string) error {
	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("create file: %w", err)
	}
	defer f.Close()

	// Header
	fmt.Fprintf(f, "# Entropia Report: %s\n\n", report.Subject)
	fmt.Fprintf(f, "**Source:** %s\n\n", report.SourceURL)
	fmt.Fprintf(f, "**Fetched:** %s\n\n", report.FetchedAt.Format("2006-01-02 15:04:05 UTC"))

	// Support Index
	fmt.Fprintf(f, "## Support Index: %d / 100\n\n", report.Score.Index)
	fmt.Fprintf(f, "**Confidence:** %s\n\n", report.Score.Confidence)
	if report.Score.Conflict {
		fmt.Fprintf(f, "**âš ï¸ Conflict Detected:** Mutually exclusive claims present\n\n")
	}

	// Detected Claims
	fmt.Fprintf(f, "## Detected Claims (%d)\n\n", len(report.Claims))
	if len(report.Claims) > 0 {
		for i, claim := range report.Claims {
			if i >= 10 {
				fmt.Fprintf(f, "\n*... and %d more claims*\n", len(report.Claims)-10)
				break
			}
			fmt.Fprintf(f, "%d. %s\n", i+1, claim.Text)
		}
	} else {
		fmt.Fprintf(f, "*No claims detected*\n")
	}
	fmt.Fprintln(f)

	// Evidence
	fmt.Fprintf(f, "## Evidence Links (%d)\n\n", len(report.Evidence))
	if len(report.Evidence) > 0 {
		// Group by authority tier
		primaryEvidence := []model.Evidence{}
		secondaryEvidence := []model.Evidence{}
		tertiaryEvidence := []model.Evidence{}

		for _, ev := range report.Evidence {
			switch ev.Authority {
			case model.TierPrimary:
				primaryEvidence = append(primaryEvidence, ev)
			case model.TierSecondary:
				secondaryEvidence = append(secondaryEvidence, ev)
			default:
				tertiaryEvidence = append(tertiaryEvidence, ev)
			}
		}

		if len(primaryEvidence) > 0 {
			fmt.Fprintf(f, "### Primary Sources (%d)\n\n", len(primaryEvidence))
			for i, ev := range primaryEvidence {
				if i >= 5 {
					break
				}
				fmt.Fprintf(f, "- [%s](%s)\n", ev.Host, ev.URL)
			}
			fmt.Fprintln(f)
		}

		if len(secondaryEvidence) > 0 {
			fmt.Fprintf(f, "### Secondary Sources (%d)\n\n", len(secondaryEvidence))
			for i, ev := range secondaryEvidence {
				if i >= 5 {
					break
				}
				fmt.Fprintf(f, "- [%s](%s)\n", ev.Host, ev.URL)
			}
			fmt.Fprintln(f)
		}

		if len(tertiaryEvidence) > 0 {
			fmt.Fprintf(f, "### Tertiary Sources (%d)\n\n", len(tertiaryEvidence))
			for i, ev := range tertiaryEvidence {
				if i >= 5 {
					break
				}
				fmt.Fprintf(f, "- [%s](%s)\n", ev.Host, ev.URL)
			}
			fmt.Fprintln(f)
		}
	} else {
		fmt.Fprintf(f, "*No evidence links found*\n\n")
	}

	// Diagnostic Signals
	fmt.Fprintf(f, "## Diagnostic Signals\n\n")
	for _, signal := range report.Score.Signals {
		icon := "â„¹ï¸"
		switch signal.Severity {
		case model.SeverityWarning:
			icon = "âš ï¸"
		case model.SeverityCritical:
			icon = "ğŸ”´"
		}

		fmt.Fprintf(f, "%s **%s**: %s\n", icon, signal.Type, signal.Description)

		// Show key data points
		if signal.Data != nil {
			if score, ok := signal.Data["score"]; ok {
				fmt.Fprintf(f, "   - Score: %v\n", score)
			}
			if formula, ok := signal.Data["formula"]; ok {
				fmt.Fprintf(f, "   - Formula: `%v`\n", formula)
			}
		}
		fmt.Fprintln(f)
	}

	// Validation Summary
	if len(report.Validation) > 0 {
		fmt.Fprintf(f, "## Validation Summary\n\n")

		accessibleCount := 0
		deadCount := 0
		staleCount := 0

		for _, v := range report.Validation {
			if v.IsAccessible {
				accessibleCount++
			}
			if v.IsDead {
				deadCount++
			}
			if v.IsStale {
				staleCount++
			}
		}

		fmt.Fprintf(f, "- Total evidence validated: %d\n", len(report.Validation))
		fmt.Fprintf(f, "- Accessible: %d (%.0f%%)\n", accessibleCount, float64(accessibleCount)/float64(len(report.Validation))*100)
		fmt.Fprintf(f, "- Dead links: %d\n", deadCount)
		fmt.Fprintf(f, "- Stale sources (>1 year): %d\n", staleCount)
		fmt.Fprintln(f)
	}

	// Principles
	fmt.Fprintf(f, "## Principles Applied\n\n")
	fmt.Fprintf(f, "- **Non-Normative**: Evaluates support, not truth\n")
	fmt.Fprintf(f, "- **Transparent**: All scoring explainable\n")
	fmt.Fprintf(f, "- **Symmetric**: Same rules for all sources\n\n")

	// Footer (optional, configurable)
	if r.IncludeFooter {
		fmt.Fprintf(f, "---\n\n")
		fmt.Fprintf(f, "*Generated by Entropia â€” a mirror, not an oracle*\n")
	}

	return nil
}

// RenderLLMMarkdown writes the LLM summary markdown to a separate file
func (r *Renderer) RenderLLMMarkdown(content string, path string) error {
	if content == "" {
		return nil
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("create file: %w", err)
	}
	defer f.Close()

	_, err = f.WriteString(content)
	if err != nil {
		return fmt.Errorf("write content: %w", err)
	}

	return nil
}

// RenderSummary renders a brief text summary to stdout
func (r *Renderer) RenderSummary(report *model.Report) {
	fmt.Printf("\n")
	fmt.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
	fmt.Printf("  Entropia Report: %s\n", report.Subject)
	fmt.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
	fmt.Printf("\n")
	fmt.Printf("  Support Index:  %d / 100  (%s confidence)\n", report.Score.Index, report.Score.Confidence)
	fmt.Printf("  Claims:         %d\n", len(report.Claims))
	fmt.Printf("  Evidence:       %d\n", len(report.Evidence))

	if report.Score.Conflict {
		fmt.Printf("  âš ï¸  Conflict:    Detected\n")
	}

	fmt.Printf("\n")
	fmt.Printf("  Signals:\n")
	for _, signal := range report.Score.Signals {
		icon := "  â„¹ï¸"
		switch signal.Severity {
		case model.SeverityWarning:
			icon = "  âš ï¸"
		case model.SeverityCritical:
			icon = "  ğŸ”´"
		}
		fmt.Printf("%s  %s\n", icon, strings.Split(signal.Description, "\n")[0])
	}

	fmt.Printf("\n")
	fmt.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
	fmt.Printf("\n")
}
